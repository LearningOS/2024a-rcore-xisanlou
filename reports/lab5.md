# 第八章报告

## 实验实现的功能



## 简答题

1. 在我们的多线程实现中，当主线程 (即 0 号线程) 退出时，视为整个进程退出， 此时需要结束该进程管理的所有线程并回收其资源。 - 需要回收的资源有哪些？ - 其他线程的 TaskControlBlock 可能在哪些位置被引用，分别是否需要回收，为什么？
    答：在exit_current_and_run_next函数中可以看到主线程需要回收的资源：从PID2PCB中删除pid；标记进程为zombie；设置exit_code;将所有子进程挂到INITPROC下面；回收所有线程的TaskUserRes;回收进程的childen列表；回收用户空间memory_set中的其它数据;取消文件句柄；删除所有线程；最后drop（process）自身。TaskControlBlock首先会被放在ProcessControlBlockInner.tasks中，在上面的函数中被删除。TASK_MANAGER中的ready_queue中也会有TaskControlBlock,代码中好像没单独回收，原因我还没了解。

2.     对比以下两种 Mutex.unlock 的实现，二者有什么区别？这些区别可能会导致什么问题？
    答：Mutex2.unlock是rcore中的解锁方法，是先从等待队列中取出等待的task放入ready队列，只有等待队列为空时才设置mutex_inner.locked = false。而Mutex1.unlock则是先设置mutex_inner.locked = false，再从等待队列中取出一个task放入ready队列中。Mutex1的问题是：当设置mutex_inner.locked = false后，如果还有尝试进入临界区但没在等待队列的线程在执行lock时不会被放入等待队列的后端，而是直接执行，会与unlock从等待队列中取出的task发生冲突。

## 第七章简答题
1. 举出使用 pipe 的一个实际应用的例子。
    答：在linux的shell中将前一个命令的输出通过管道传递给下一个命令作为输入，如【ls *.txt|wc -l】,是计算目录下以.txt为后缀的文件的数目。

2. 如果需要在多个进程间互相通信，则需要为每一对进程建立一个管道，非常繁琐，请设计一个更易用的多进程通信机制。
    答：可以使用共享内存的技术。通个shmget调用建立一块共享内存，并记录共享内存使用的物理页号，并返回共享内存的标识ID。使用者使用shmat系统调用，将共享内存ID和一个用户空间地址作为参数，shmat通过共享内存ID取回其物理页号，然后映射到参数中指定的自己的虚拟内存空间中的地址，然后使用者可以对这一地址进行读写，实现进程间通讯。为了防止静态条件，可以设置权限，使所有者可写，其他人只读，或者使用锁机制。




## 荣誉规则

1.在完成本次实验的过程（含此前学习的过程）中，我曾分别与 以下各位 就（与本次实验相关的）以下方面做过交流，还在代码中对应的位置以注释形式记录了具体的交流对象及内容：

        《未与他人对实验进行交流》

2.此外，我也参考了 以下资料 ，还在代码中对应的位置以注释形式记录了具体的参考来源及内容：

        《未参考其他资料》

3. 我独立完成了本次实验除以上方面之外的所有工作，包括代码与文档。 我清楚地知道，从以上方面获得的信息在一定程度上降低了实验难度，可能会影响起评分。

4. 我从未使用过他人的代码，不管是原封不动地复制，还是经过了某些等价转换。 我未曾也不会向他人（含此后各届同学）复制或公开我的实验代码，我有义务妥善保管好它们。 我提交至本实验的评测系统的代码，均无意于破坏或妨碍任何计算机系统的正常运转。 我清楚地知道，以上情况均为本课程纪律所禁止，若违反，对应的实验成绩将按“-100”分计。
